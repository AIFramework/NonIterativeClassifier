# NonIterativeClassifier
Классификатор с безытеративным обучением

* Безытеративное обучение, это обучение классификатора за одну итерацию, прямой расчет весовых коэффициентов

Этой темой я занимаюсь довольно давно, написал 3 статьи по ней, 2 на хабр, ссылки ниже, одну в рамках студ. конференции. Также эта стратегия обучения, 3 года назад, легла в основу моей бакалаврской работы, в которой я классифицировал сигналы. Сейчас решил, что необходимо опубликовать сжатую теорию и код данного метода, т.к. на мой взгляд технология очень перспективная. 

Мотивация заключается в следующем, если мы сможем обучать нейронные сети безытеративно, то, вероятно, сможем это делать в разы быстрее, чем это делают итеративные алгоритмы. 

Статьи на Хабр: 
 * [Метод безытеративного обучения однослойной сети прямого распространения с линейной активационной функцией](https://habr.com/ru/post/332936)
 * [Безытеративное обучение однослойного персептрона. Задача классификации](https://habr.com/ru/post/333382)


## Тест

* Датасет: "Ирисы Фишера"
* Тренировочная выборка: 25%
* Тестовая выборка: 75%
* Время обучения: 0,000278
* F1 мера: 84,06%

## Код теста

```c#

            classifier = new SimpleClassifier(3, 4); // Создание классификатора, 3 класса, 4 признака

            var dataset = GetIrisDataset(); // Получение датасета
            Shuffling<VectorClass>.Shuffle(dataset); // Равномерное перемешивание
            int len = dataset.Length, len25 = len / 4, len75 = len - len25;
            // Обучающая / тестовая выборка
            var test = new VectorClass[len75]; 
            var train = new VectorClass[len25];
            for (int i = 0; i < len75; i++) test[i] = dataset[i];
            for (int i = 0; i < len25; i++) train[i] = dataset[i+len75];


            VectorIntDataset vectorClasses = new VectorIntDataset();
            vectorClasses.AddRange(train); // Добавление обучающей выборки
            Stopwatch stopwatch = new Stopwatch();


            stopwatch.Start(); // Цикл на 100 итераций нужен только для точности замера времени, в реальной работе следует его убрать
            for (int i = 0; i < 100; i++) classifier.Train(vectorClasses); // Обучение
            stopwatch.Stop();
            Console.WriteLine($"Время обучения: {stopwatch.ElapsedMilliseconds / (1000.0 * 100.0)} сек");

            //classifier.Train(vectorClasses); // Обучение

            Console.WriteLine("=====================================================".ToUpper());
            Console.WriteLine("\n\n===== Безытеративный классификатор ===== \n\n\n".ToUpper());
            Console.WriteLine("=====================================================".ToUpper());
            
            Test(test); // Тестирование



            Console.WriteLine("\n\n\nКонвертирование в нейросеть".ToUpper());
            Console.WriteLine("=====================================================".ToUpper());
            classifier = new NeuralClassifier((classifier as SimpleClassifier).GetNetwork() as NNW) { EpochNum = 3};
            Test(test); // Тестирование


            Console.WriteLine("\n\n\n Тюнинг методом Adam".ToUpper());
            Console.WriteLine("=====================================================".ToUpper());
            Console.WriteLine("\n\n");
            classifier.Train(vectorClasses);
            Console.WriteLine("\n\n");
            Test(test); // Тестирование
```

## Полная информация о тесте

``` 
Время обучения: 0,00049 сек
=====================================================


===== БЕЗЫТЕРАТИВНЫЙ КЛАССИФИКАТОР =====



=====================================================
Precision:             0,8070   80,70%
Average Recall:      0,8708     87,08%
FMeasure:            0,8377     83,77%
Accuracy:            0,8053     80,53%


--Precision value for each class--

Class #1:  1,0000       100,00%
Class #2:  0,4211       42,11%
Class #3:  1,0000       100,00%



КОНВЕРТИРОВАНИЕ В НЕЙРОСЕТЬ
=====================================================
Precision:             0,8070   80,70%
Average Recall:      0,8708     87,08%
FMeasure:            0,8377     83,77%
Accuracy:            0,8053     80,53%


--Precision value for each class--

Class #1:  1,0000       100,00%
Class #2:  0,4211       42,11%
Class #3:  1,0000       100,00%



 ТЮНИНГ МЕТОДОМ ADAM
=====================================================



----------------------- ONLINE MODE ---------------------------
epoch[1/3]  tr. loss = 0,074
epoch[2/3]  tr. loss = 0,071
epoch[3/3]  tr. loss = 0,070
---------------------- Trainer stoped! ------------------------



Precision:             0,8943   89,43%
Average Recall:      0,9037     90,37%
FMeasure:            0,8990     89,90%
Accuracy:            0,8938     89,38%


--Precision value for each class--

Class #1:  1,0000       100,00%
Class #2:  0,7368       73,68%
Class #3:  0,9459       94,59%

```


### 03.05.21

* Расчет весов смещения
* Конвертирование в нейросеть
* Тюнинг градиентными методами


## Дорожная карта

- [x] Замена, при обучении, скалярных произведений на корреляцию Пирсона(для более устойчивой работы)
- [x] Замена сигмоидальной функции на софтмакс
- [x] Базовый расчет важности весов и применение этих знаний при обучении(расчете)
- [x] Распараллеленное обучение и работа
- [x] Расчет весов смещения
- [x] Конвертирование в полносвязный слой нейросети
- [x] Тюнинг градиентными методами
- [ ] Более сложный расчет важности весовых коэффициентов
- [ ] Работа с сильнокоррелированными признаками, когда корреляционная матрица не диагональная
- [ ] Многослойные архитектуры
- [ ] Коррекция весов
- [ ] Обучение ансамблем методов
- [ ] Онлайн обучение

---

* Замеры точности и матричные операции выполнены с использованием нашего фреймворка для машинного обучения: [AIFramework 2.1 Free](https://github.com/AIFramework/AI_Free) 
