# NonIterativeClassifier
Классификатор с безытеративным обучением

* Безытеративное обучение, это обучение классификатора за одну итерацию, прямой расчет весовых коэффициентов

Этой темой я занимаюсь довольно давно, написал 3 статьи по ней, 2 на хабр, ссылки ниже, одну в рамках студ. конференции. Также эта стратегия обучения, 3 года назад, легла в основу моей бакалаврской работы, в которой я классифицировал сигналы. Сейчас решил, что необходимо опубликовать сжатую теорию и код данного метода, т.к. на мой взгляд технология очень перспективная. 

Мотивация заключается в следующем, если мы сможем обучать нейронные сети безытеративно, то, вероятно, сможем это делать в разы быстрее, чем это делают итеративные алгоритмы. 

Статьи на Хабр: 
 * [Метод безытеративного обучения однослойной сети прямого распространения с линейной активационной функцией](https://habr.com/ru/post/332936)
 * [Безытеративное обучение однослойного персептрона. Задача классификации](https://habr.com/ru/post/333382)


## Тест

* Датасет: "Ирисы Фишера"
* Тренировочная выборка: 25%
* Тестовая выборка: 75%
* Время обучения: 0,000278
* F1 мера: 84,06%

## Код теста

```c#

            classifier = new SimpleClassifier(3, 4); // Создание классификатора, 3 класса, 4 признака

            var dataset = GetIrisDataset(); // Получение датасета
            Shuffling<VectorClass>.Shuffle(dataset); // Равномерное перемешивание
            int len = dataset.Length, len25 = len / 4, len75 = len - len25;
            // Обучающая / тестовая выборка
            var test = new VectorClass[len75]; 
            var train = new VectorClass[len25];
            for (int i = 0; i < len75; i++) test[i] = dataset[i];
            for (int i = 0; i < len25; i++) train[i] = dataset[i+len75];


            VectorIntDataset vectorClasses = new VectorIntDataset();
            vectorClasses.AddRange(train); // Добавление обучающей выборки
            Stopwatch stopwatch = new Stopwatch();


            stopwatch.Start(); // Цикл на 1000 итераций нужен только для точности замера времени, в реальной работе следует его убрать
            for(int i = 0; i<1000; i++) classifier.Train(vectorClasses); // Обучение
            stopwatch.Stop();
            Console.WriteLine($"Время обучения: {stopwatch.ElapsedMilliseconds /(1000.0* 1000.0)} сек");

            Console.WriteLine("=====================================================".ToUpper());
            Console.WriteLine("\n\n===== Безытеративный классификатор ===== \n\n\n".ToUpper());
            Console.WriteLine("=====================================================".ToUpper());
            
            Test(test); // Тестирование
```

## Полная информация о тесте

``` 
Время обучения: 0,000278 сек
=====================================================


===== БЕЗЫТЕРАТИВНЫЙ КЛАССИФИКАТОР =====



=====================================================
Precision:           0,8400     84,00%
Average Recall:      0,8412     84,12%
FMeasure:            0,8406     84,06%
Accuracy:            0,8407     84,07%


--Precision value for each class--

Class #1:  0,9737       97,37%
Class #2:  0,7895       78,95%
Class #3:  0,7568       75,68%

```

## Дорожная карта

- [x] Замена, при обучении, скалярных произведений на корреляцию Пирсона(для более устойчивой работы)
- [x] Замена сигмоидальной функции на софтмакс
- [x] Базовый расчет важности весов и применение этих знаний при обучении(расчете)
- [x] Распараллеленное обучение и работа
- [ ] Более сложный расчет важности весовых коэффициентов
- [ ] Расчет весов смещения
- [ ] Конвертирование в полносвязный слой нейросети
- [ ] Работа с сильнокоррелированными признаками, когда корреляционная матрица не диагональная
- [ ] Многослойные архитектуры
- [ ] Коррекция весов однократным вызовом градиентного спуска
- [ ] Обучение ансамблем методов

---

* Замеры точности и матричные операции выполнены с использованием нашего фреймворка для машинного обучения: [AIFramework 2.1 Free](https://github.com/AIFramework/AI_Free) 
